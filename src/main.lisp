;; Circular Queue Macros
;; ===============================

;; Create a circular queue, binding it to queue.
(defmacro circular-queue-create (queue)
  `())

;; Get the item at the front of the queue.
(defmacro circular-queue-front (queue)
  `(car ,queue))

;; Push an item onto the back of the queue without evaluating the item.
(defmacro circular-queue-push (queue item)
  `(append ,queue (list ,item)))

;; Pop the item on the front of the queue.
(defmacro circular-queue-pop (queue)
  `(cdr ,queue))

;; Advance the circular queue by moving the front element to the back.
(defmacro circular-queue-advance (queue)
  `(circular-queue-pop (append ,queue (list (circular-queue-front ,queue)))))





;; Board Structure and Primitives (things which understand pieces)
;; ===============================

;; This structure functions as an abstraction separating the game board from the implementation.
(defstruct board
  (board (make-array '(8 8) :initial-element '())))

;; Build a square board of dimension dim.
(defmacro build-board (dim)
  `(make-board :board (make-array '(,dim ,dim) :initial-element '())))

;; Get the dimension of the board.
(defmacro board-dim (board)
  `(array-dimension (board-board ,board)))



;; Get the type of the piece at spot.
(defun board-piece-get (board spot)
  (aref (board-board board) spot))



;; Set the type of piece at spot.
(defun board-piece-set (board spot newpiece)
  ())





;; Move Structure and Board Operations using Moves (things which understand moves)
;; ===============================

;; This structure functions as an abstraction between specifying movements and computing their results.
(defstruct move
  (origin '(0 0))
  (dir '(() ())))

;; Simplified syntax for building moves.
(defmacro build-move (origin dir)
  `(make-move :origin ',origin :dir ',dir))



;; Should this be a macro?
(defmacro inc-if-dec-else (term func)
  `(+ ,term (if ,func 1 -1)))



;; Find the destination of a move based on the origin.
;; Might need a rewrite, do some experiments.
(defun move-destination (move)
  (let
    ((origin (move-origin move))
     (dir (move-dir move)))
    (list (inc-if-dec-else (first origin) (eq (first dir) 'NORTH)) (inc-if-dec-else (second origin) (eq (second dir) 'EAST)))))



;; Get possible moves on the board by a piece at a given location.
(defun board-moves-piece (board piece-spot)
  ;; Cond here.
  ())



;; Get possible moves on the board by pieces represented by a given symbol.
(defun board-moves-symbol (board piece-symbol)
  ())



;; Validate a given move to make sure it is legal on the board. Not implemented.
;;(defun board-validate-move (board move)
;;  ())



;; Apply the supplied move to the board. Unsafe, as it does not do validity or error checking.
;; Unless you are sure the move is valid (i.e. it was generated by board-moves), use state-validate-move to check the move first.
;; Non-destructive.
(defun board-apply-move (board move)
  (let*
    (destination (move-destination move))
    (board-piece-set (board-piece-set board (move-origin move) '()) destination (board-piece-get board destination))))





;; Player Structure and Operations, including Move Selectors (things which understand colors)
;; ===============================

;; This structure associates a piece color with a move selection algorithms.
;; The lack of default values is intentional, for now.
(defstruct player color select-move)

;; Macro to simplify constructing players.
(defmacro build-player (color select-move)
  `(make-player :color ',color :select-move ',select-move))



;; Get possible moves on the board by pieces of the given color.
(defun board-moves-color (board piece-color)
  ())

;; Get possible moves on the board by pieces of the given player.
(defmacro board-moves-player (board piece-player)
  `(board-moves-color ,board (player-color ,piece-player)))



;; Select a random move from the list of possible moves.
(defun select-move-rand (state player)
  (let
    ((moves (board-moves-player (state-board state) player)))
    (nth (random (length moves)) moves)))



;; Use MCTS to select a move from the list of possible moves.
(defun select-move-mcts-serial (state player budget)
  ())



;; Use parallel MCTS to select a move from the list of possible moves.
(defun select-move-mcts-parallel (state color budget)
  ())





;; State Structure and Operations (things which understand state)
;; ===============================

;; This structure defines the state of a game.
(defstruct state 
  (board (make-board))
  (players '()))

;; Macro to simplify constructing the state.
(defmacro build-state (board players)
  `(make-state :board ',board :players ',players))

;; Macro to simplify constructing the state.
(defmacro build-state-list (proplist)
  `(cons build-state ,proplist))

;; Get the dimension of the state's board.
(defmacro state-dim (state)
  `(board-dim (state-board ,state)))



;; Read the state from instream.
;;(defun struct-state-read (state instream)
;;  ())



;; Write the state to outstream.
;;(defun struct-state-write (state outstream)
;;  ())





;; Checkers Playthrough Algorithm (a thing which understands Checkers)
;; ===============================

;; Algorithm for playing the checkers game through to the end and returning the winning player.
(defun play-game (state)
  (let*
    (
     ;; Bind the board.
     (board (state-board state))
     
     ;; Bind the dimension of the board.
     (dim (board-dim board))

     ;; Bind the player queue.
     (players (state-players state))

     ;; Find the current player.
     (current-player (circular-queue-front players)))

    (if
      ;; Test to see if only one player remains.
      (eq (cdr players) '())

      ;; If only the current player remains, return that player.
      current-player

      ;; Otherwise, activate the recursive step.
      (let*
        (
         ;; Bind the current player's move selector.
         (current-player-select-move (struct-player-select-move current-player))

         ;; Find the current player's options for movement.
         (current-player-moves (board-moves board current-player))

         ;; Find the new state of the game.
         (new-state 
           (build-state-list
             (if
               ;; Test for the existence of possible moves.
               (eq current-player-moves '())

               ;; If the player has no possible moves, the board remains unchanged and the current player is removed from the queue.
               ();;(list board (circular-queue-remove-front players))

               ;; Otherwise, the player's chosen move is applied to the board while the player queue is advanced.
               (list (state-apply-move state (current-player-select-move state current-player)) (circular-queue-advance players))))))

        ;; Advance the game by making a recursive call.
        (play-game new-state)))))





;; Top Level
;; ===============================
;; Might excise this to a sort of script later.

;; Create the board.
(setf myboard (make-board))

;; Create the player queue.
(circular-queue-create myplayers)

;; Add the red and black players, random and serial MCTS respectively, MCTS budget of 1000 milliseconds.
;;(circular-queue-push players (struct-player :color 'red :get-move 'select-move-rand))
;;(circular-queue-push players (struct-player :color 'black :get-move 'select-move-mcts-serial))

;; Add the read and black players, both random.
(setf myplayers (circular-queue-push myplayers (build-player red select-move-rand)))
(setf myplayers (circular-queue-push myplayers (build-player black select-move-rand)))

;; Build the state.
(setf mystate (build-state myboard myplayers))

;; ROUND 1, FIGHT!
(print (play-game mystate))
